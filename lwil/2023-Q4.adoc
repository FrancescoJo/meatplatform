= 2023년 3분기 10월-12월 LWIL(Last week I learnt) 모음
// Metadata:
:description: Last Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font

[[section-202310]]
== 2023년 10월

[[section-202310-W1]]
=== 2023년 10월 1주
- hwan: 유명한 js 라이브러리인 lodash 에는 link:https://github.com/lodash/lodash/blob/main/src/sample.ts[sample] 과 link:https://github.com/lodash/lodash/blob/main/src/sampleSize.ts[sampleSize] 라는 로직이 있다. 테스트 뿐 아니라 이벤트 당첨자 추첨 같은 실제 비즈니스 로직에서도 종종 유용하게 사용했던 경험이 있다. 그런데 요즘 주로 사용하는 kotlin 에는 비슷한 함수가 없어 `Iterable<*>.shuffled().take(M)` 같은 호출을 해야 한다. 이 호출 chain 의 경우 입력 `Iterable` 의 크기를 `N` 이라고 하고, take 의 파라미터 크기를 `M` 이라 가정한다면, `M` < `N` 일수밖에 없음에도 시간과 공간 복잡도가 항상 `N` 이 나온다. 이 점이 이상하다고 생각해서, 시간과 공간 복잡도를 `M` 으로 줄여보려 했더니 Random Accessible `Iterable` 이라는 아주 한정적인 상황에서만 가능하다는 것을 알게 되었다. 왜냐면 `Iterable` 은 Random Access 가 불가능하기 때문에 `shuffle` 이 없는 `sample` 을 할 경우, 같은 `M` 에 대해 항상 같은 결과만 나오게 되어 로직이 그다지 쓸모 없게 된다.
+
Kotlin standard library 에서는 이 문제를 link:https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/native-wasm/src/kotlin/collections/Collections.kt#L83[이렇게 해결]하고 있었다. 나는 처음 `shuffle` 이라는 문제를 받아들였을 때 `shuffle` 의 결과는 입력과 무조건 달라야 한다고 생각했었는데 따지고 보면 그럴 필요가 없다. 섞더라도 원본이 나올 수 있으니까. 즉, 처음부터 접근을 잘못하면 이 문제는 쓸데없이 복잡해 지는 문제라는 것을 알게 되었다. 참고로 Kotlin native 의 구현은 Fisher-Yates shuffle algorithm 을 참고하고 있는데, 이 로직은 시간 복잡도와 공간 복잡도가 O(`N`) 이며, 입력과 섞은 결과가 일치할 확률은 `1/N²` 으로 N 이 커질수록 같을 확률이 급격하게 0에 수렴하게 된다.
