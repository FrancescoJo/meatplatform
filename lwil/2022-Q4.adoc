= 2022년 4분기 10월-12월 LWIL(Last week I learnt) 모음
// Metadata:
:description: Last Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font


[[section-202210]]
== 2022년 10월

[[section-202210-W1]]
=== 2022년 10월 1주

- hwan: Compile-time DI framework 인 Dagger2 를 이용할 때의 주요 의사결정 기준

1. `@Inject` 를 반드시 생성자에 붙여줘야 Dagger2 가 DI 를 위한 추가 코드를 만들어 준다.
2. 직접 생성이 어려운 컴포넌트들을 별도로 생성하는 `@Module` 을 만든다. 가령, EhCache 의 `CacheManager.getInstance()` 같은 이용사례가 좋은 예가 될 듯.
3. 구체 타입 대신 Interface 를 노출하고 싶다면 `@Provides` 메소드를 생성한다.
4. Spring IoC 와 달리 `@Singleton` 이 기본이 아니므로, 잘 판단해서 `@Singleton` 을 붙여줘야 한다.
5. `@Component` 는 흩어진 `@Module` 들을 한데 모으는 역할을 한다. 다만 이쯤 되면, 전체 DI graph 를 쉽게 알아볼 수 있는 수단을 마련해 둬야 유지보수에 어려움이 없다.
6. Field level 에 `@Inject` 를 써도 좋지만, Spring 의 `@Autowired` 의 사례에서 보듯 묵시적인 의존성 선언은 프로그램 유지보수성을 크게 해친다. 가급적 `@Inject` 는 생성자에만 쓰도록 한다.
7. Dagger2 는 현재까지는 Java 기반이기 때문에 kotlin/native 나 kotlin/js 에서는 활용할 수 없다. Kotlin multiplatform 에서 DI 를 쓰고싶다면 2022년 현재까지는 link:https://insert-koin.io/[Koin], link:https://github.com/kosi-libs/Kodein[Kodein] 같은 프레임워크를 써야 한다. 개인적으로는 Koin 이 좀 더 쓰기 쉬웠다.

- youjin: MSA 는 `MicroService Architecture` 이다. 처음 개념을 익혔을 때, 독립적으로 db를 분리한다는 점은 아키텍쳐 관점에서 좋은 점이라고 생각했다. 하지만 클라이언트와 네트워킹을 할 때, 비용이 커서 불리하지 않을까의문이 들었다. 하지만 이는 api gateway를 통해 보완할 수 있었다. 클라이언트에서 하나의 요청을 받고 서버에서는 여러 api 를 조합한 후 API gateway를 통해 하나로 보낼 수 있기 때문이다. 그 다음으로 의문은, 트랜잭션의 단위는 도메인에 따라 조합된 경우(의존, 혹은 순서가 있거나 없거나 등등)가 많은데, 이때마다 서로 독립적으로 분리된 db를 어떻게 join 시키는지 의문이 들었다. 이를 보완하기 위해서는 필요한 db들을 조합하여 readOnly한 db를 생성하고 이를 구독하면서 보완할 수 있었다. 하지만 이 방법을 단점은 구독하고 있기 때문에 구독후, 업데이트 시점에서 시간차가 확연히 있다는 점이다. server 쪽은 잘 모르는 분야였는데 우연히 공부하게 되면서 시야가 넓어진 느낌이다.

- wongue: Js 에서도 Java나 Dart 와 같은 Steam API 가 정의되어있다는걸 알게되었다. 참고자료: link:https://developer.mozilla.org/en-US/docs/Web/API/Streams_API[mozilla_Stream] +
Stream 은 굳이 대규모 Http 통신에만 국한되지 않고, 여러 함수형 프로그레밍에서 유용하게 사용될 수 있는 도구인데, 심지어 이미 만들어져 있는데 왜 이걸 이전에 듣지 못했을까 궁금하다.

- yoonho: Martin Fowler 의 link:https://martinfowler.com/bliki/EvansClassification.html[EvansClassification] 을 읽고: +
entity 는 고유성 가지는 객체이다. + 
entity 의 동일성은 내부 속성 값에 좌우되지 않는다. +
각각의 entity가 서로 다른 속성 값을 가지고 있다 하더라도 동일한 고유성을 나타낼 수 있다면, 그것은 동일한 entity라고 할 수 있다. +
각각의 entity가 서로 같은 속성 값을 가지고 있다 하더라도 고유성이 동일하지 않다면, 그것은 동일한 entity라고 할 수 없다. +
value object 는 내부 속성 값에 따라 좌우된다. +
각각의 value object 의 속성 값이 같으면, 그것은 같은 value object 라고 할 수 있다.

- gon: redis의 java 진영 client 구현체중 하나인 redisson은 스핀락을 사용하지 않아 redis에 부담을 덜어준다. 스핀락은 매번 redis에 직접 호출하는 식이고 redisson은 pub/sub으로 lock을 구현한다 redis한테 lock을 걸어도되는 상황인지를 sub을 이용하여 판단하기때문에 요청의 횟수가 굉장히 줄어든다

[[section-202210-W2]]
=== 2022년 10월 2주

- wongue: link:https://i.imgur.com/oRJH7A0.jpg[string_type_in_JAVA] C와 JAVA의 문자열(ASCIZ)의 내부 구현이 어떠한 식으로 작성되었는지를 알게 되었다. +
"\0" null char 를 찾기 전까진 문자열이 끝나는것을 알 수 없기 때문에, 문자열의 길이를 알기 위해서는 정말 직접 세 보는 방법 말고는 답이 없다.. +
그렇기 때문에 자바에서는 문자열 자체를 immutable 하게 두고, 생성 시점에 length 를 파악해서 String 인스턴스의 내부에서 field 로 들고있는 듯 하다. +
참고자료 : link:http://www.tcpschool.com/c/c_string_string[C의 문자열] +

- hwan: Dart 에서는 empty collection literal 을 다음과 같이 표현한다.
+
[source,dart]
----
{}    // unordered collection literal
[]    // ordered collection literal
----
+
그래서 `[]` 는 `List` 에, `{}` 는 `Set`, `Map` 에 대응할 수 있다.

- gon: https://www.youtube.com/watch?v=v0AHdAIBnbs
이제 코틀린에서 다음과같은 문법을 지원한다 (1.7.10 기준)
```
(1 ..< 10) 1 부터 9까지
```
'..<' 이라는 오퍼레이터가 새로 생겻다.
추가로 날짜도 오퍼레이터를 이용한 비교가 가능하다
```
val jan1 = LocalDate.of(2022,1,1)
val apr1 = LocalDate.of(2022,4,1)
val q1 = jan1..<apr1
println(apr1 in q1)
```
날짜를 오퍼레이터로 비교하는 기능도 가능하다! 해당기능은 신규기능인지느 잘 모르겠다ㅎ

- youjin: 텍스트를 이미지로 표현하는 open ai dall.e2[https://openai.com/dall-e-2/] 라는 프로그램이 있다.
