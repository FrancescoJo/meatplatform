= 2023년 2분기 04월-06월 LWIL(Last week I learnt) 모음
// Metadata:
:description: Last Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font

[[section-202304]]
== 2023년 4월

[[section-202304-W1]]
=== 2023년 4월 1주
- youjin: Flutter 에서 go-router 를 개인프로젝트에 도입해보았다. 생각보다 오래걸리진 않았지만, 본대로 플랫폼에 도입하게 된다면 해당하는 스크린들이 많아서 시간이 꽤 걸릴것으로 예상한다. +

- yoonho: + 
즐거움은 멀리있지 않다. +
만발한 벚꽃과 사람이 가득한 여의도 벚꽃 축제보다 +
집 앞의 핀 벚꽃 나무 한 그루의 잔잔힘이 더 큰 의미를 안겨줄수 있다.

- hwan: Kotlin 의 `Iterable<T>.first` 와 `Iterable<T>.single` extension function 의 차이 +
+
* `first` 는 여러개의 T 들 중 제일 먼저 나오는 한개만을 찾겠다는 의미
* `single` 은 여러개의 Iterable 로 감싸져 있는 T 의 갯수는 오직 하나여야 하며 그 하나만을 가져오겠다는 의미
+
즉, 이런 문맥의 코드에서는 `first` 보다 `single` 이 문맥상 더 올바르다.
+
[source, kotlin]
----
fun save(tag: ProductTag): ProductTag = saveAll(listOf(tag)).single()   // first 대신 single

fun saveAll(tags: Collection<ProductTag>): List<ProductTag>
----

- gon : CAS는 현재 스레드가 가지고 있는 기존값과 메모리가 가지고 있는 값을 비교해 같은 경우 변경할 값을 메모리에 반영하고 true를 반환한다. 다른 경우에는 변경값이 반영되지 않고 false를 반환한 다음 재시도를 하는 방식으로 동작한다. CAS방식을 통해 가시성과 원자성 문제를 해결할 수 있다.

- wongue:
 흔히 RH-O blood type 의 경우 모든 혈액형에 수혈이 가능하다 알려져 있지만, 사실 그렇게 쓰이진 않는다고한다. +
 1. RH-O 의 인구수가 적어 그 타입끼리 수혈하기도 빠듯하고, +
 2. 소량의 경우는 수혈이 가능하지만, 대량 수혈은 거부반응이 일어나기 떄문이다. +
 

[[section-202304-W2]]
=== 2023년 4월 2주
- wongue: Flutter 의 정체성은 "강력한 크로스 플랫폼 UI Framework"이다. +
즉, Flutter 의 한계또한 "크로스 플랫폼 UI Framework" 이라는 정체성에서 정해지게 된다. +
하드웨어에 밀접한 기능, OS 의 강력한 권한을 이용해야하는 기능, UI 가 없는 Background 에서 수행되어야 하는 기능 등을 개발할때는 Flutter 는 큰 도움이 되기 힘들다. +
결국 실행되는 환경에 따른 각각의 네이티브 로직이 들어서야 할 필요성이 있는데, +
아직 다룰 수 있는 기술 스텍이 Flutter 밖에 없는 나는 UI 개발자라고는 할 수 있지만, "클라이언트 개발자" 로서는 반쪽짜리가 아닌가 싶다. +
진정한 "크로스 플랫폼 클라이언트 전문가" 가 되기 위해선, 적어도 IOS, Android, Web 세 네이티브 환경에 대한 많은 경험과 지식이 동반되어야 하는게 아닐까.
- youjin: dart 에서는 같은 enum 타입의 value인지 비교하는 구문에서 컴파일러가 다른 타입과 비교하는지, 미리 잡아주지 않는다. +
```dart
  // ele.productImageType 이 ProductImageTypeDTO 이었지만, ProductImageType 으로 같은지 비교하고 있었다.
  // 하지만 컴파일타임에서 알수가 없고, false가 나올 것이기 때문에, orElse 구문을 항상 타고 있었다.
    HanwooMediaDto thumbNailDto = mediaDtoList.firstWhere((ele) => ele.productImageType == ProductImageTypeDTO.MAIN,
        orElse: () => HanwooMediaDto.whenReceivedNull());
```

- gon : 코드 품질이 사업에 영향을 담은 유튜브 영상이 있어서 가져왔다
https://www.youtube.com/watch?v=lcvZ9kBn2_M
결론은 코드 품질은 결국엔 더 빠른 개발, 더 적은 결함을 만들어준다고 한다

- hwan: Jackson 에서 Request/Response 를 아래처럼 정의할 경우, `Optional` 이 `{ "present": "VALUE" }` 처럼 직렬 / 역직렬화 되지 않고 그 안의 값만 알아서 잘 들어가는 사례를 발견함. 이를 이용해 Typed language 에서 구현하기 까다로운 HTTP GET / PATCH 를 그나마 쉽게 구현할 수 있다.
+
예를 들어 아래와 같은 Request 를
+
[source,kotlin]
----
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonDeserialize
class EditUserRequest : EditUserUseCase.Message {
    @get:JsonProperty
    @get:JsonPropertyDescription(DESC_NAME)
    override var name: Optional<String>? = null

    /** 생략시 업데이트 하지 않습니다. null 입력 불가능. */
    @get:JsonProperty
    @get:JsonPropertyDescription(DESC_AGE)
    override var age: Optional<Int>? = null

    /**  생략시 업데이트 하지 않습니다. null 입력 가능. */
    @get:JsonProperty
    @get:JsonPropertyDescription(DESC_ADDRESS)
    override var address: Optional<String>? = null
}
----
+
Wire 로 아래처럼 보낼 경우:
+
[source,shell]
----
Request method:	PATCH
Request URI:    http://localhost:32807/api/v1/user/a2e1cfb3-896c-4366-9c0d-fcaf57ca5543
Proxy:          <none>
Request params: <none>
Query params:   <none>
Form params:    <none>
Path params:    <none>
Headers:        Content-Type=application/json
Cookies:        <none>
Multiparts:     <none>
Body:
{
    "age": 33,
    "address": null
}
----
+
로직에서 확인하는 값은 다음과 같다.
+
[source,shell]
----
instance of EditUserRequest {
  name : null
  age : Optional[33]
  address: Optional.empty
}
----
+
즉 field 를 `Optional` 로 감싼 request 를 만났을 경우, field 가 `null` 이라면 생략된 필드(`undefined`) 이므로 업데이트 대상에서 배제, `Optional` 을 꺼낸 값의 `null` 허용여부는 Request handler 에서 직접 처리하는 식으로 GET/PATCH 상황에서의 `undefined` 를 흉내낼 수 있다.
+
link:https://github.com/FasterXML/jackson-modules-java8/tree/2.15/datatypes/src/main/java/com/fasterxml/jackson/datatype/jdk8[Jackson Optional Serializer/Deserializer]
+
아마 Response 에서도 같은 원리로 동작할 것으로 예상된다.

[[section-202304-W3]]
=== 2023년 4월 3주
- youjin: hash 값을 사용하는 Collection(HashMap, HashSet, HashTable)은 객체가 논리적으로 같은지 비교할 때, hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true여야 논리적으로 같은 객체라고 판단한다. 따라서, equals와 hashCode는 항상 같이 재정의해주는 것이 좋다.

- wongue: 주말에 flame 이라는 Flutter base 2D-engin 을 만져봤는데, 이 엔진의 주요 기능은 여러 그림을 담은 이미지를 분기별로 잘 잘라 주고, 충돌 감지를 제공해준다. +
퍼포먼스 떄문인지, 제공되는 api interface 가 상당히 저수준이여서 신선했다.
- hwan: 무통장 입금을 비즈니스 로직으로 처리하기 까다로운 이유
  * 무통장 입금은 고객이 상품을 획득하기 원하지만, 아직 입금은 되지 않은 상태가 계속되는 상태다. 즉, 일종의 미수 거래다. 
  * 시스템에서는 판매 완료되었으며, 고객에게 인계된다는 상태를 표시하기 위해 고객이 지정한 상품을 진열하지 않아야 한다.
  * 하지만 그 상품은 언제든지 진열 상태를 복구할 수도 있어야 한다.
  * 고객이 구매 완료후 최대 n시간 (보통 24시간을 maximum 으로 침) 이후에도 입금 내역에 변경이 없다면 진열 상태를 복구해야 한다.
  * 그런데 HTTP 요청으로 표현하는 workflow 에서는 입금이 완료되었다는 상태를 알기 어렵다. 클라이언트가 입금 끝내거나, 또는 최대 24시간동안 request 를 붙잡아 두고 있어야 하기 때문.
  * 입금상태를 확인하는 별도 로직은 은행 API 를 폴링하거나, 그쪽에서 제공하는 callback 을 application logic 에 중계해야 한다.
  * 은행 종류가 한두개가 아니기 때문에 이 경우 payment gate(PG) 서비스를 이용하는 편이 정신건강에 이롭다.
  * 그런데 PG 서비스도 종류가 여러개다. 이미 추상화를 한단계 거친 PG 들을 다시 추상화 하는 일이 필요하다.
  * 즉 무통장 입금은 생각해야 할 요소들이 다양하고, 비동기로 동작하는 요소들이 잘 맞물리도록 동기화를 맞추는 일이 필요해서 어렵다.
  
 - gon : 네크워크를 공부하다가 ios 운영체제가 나왔다. 제가 아는 ios 운영체제는 애플에서 만든 os인데 네트워크에서 갑자기 왜 나오나 했다. + 
 좀더 알아보니 Internetworking Operating System(IOS)의 약자이며 네트워크 장비 업체로 유명한 시스코 장비의 네트워크 운영체제 소프트웨어입니다

[[section-202304-W4]]
=== 2023년 4월 4주
- hwan: Exception 이 비싼 operation 인 이유: stack trace 를 모두 기억해야 하기 때문에 그렇다. 참고로 C++ 에서도 exception 은 비싸다. link:https://www.baeldung.com/java-exceptions-performance[참고자료]

[[section-202305-W1]]
=== 2023년 5월 1주
- hwan: 5월 1일은 근로자의 날이다. 전 세계적으로 May Day 라고 해서 모든 근로자들이 기념하는 날이기도 하다. 그런데 특이하게 미국은 5월 1일이 아니라 9월 4일을 link:https://en.wikipedia.org/wiki/Labor_Day[Labor Day] 라고 기념한다고 한다.
