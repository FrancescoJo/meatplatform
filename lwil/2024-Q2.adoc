= 2024년 2분기 04월-06월 LWIL(Last week I learnt) 모음
// Metadata:
:description: Last Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font

[[section-202404]]
== 2024년 04월

[[section-202404-W1]]
=== 2024년 04월 1주
- hwan: Kotlin 에서는 extension function 도 상속을 이용한 확장 구현이 된다. Template pattern 에서 유용하게 활용할 수 있는 테크닉인듯...
+

[source, kotlin]
----
abstract class Converter<T, U> {
    protected abstract fun T.convert(): U
}

class StringToNumberConverter : Converter<String, Number> {
    override fun String.convert(): Number {
        // ..
    }
}

class StringToUuidConverter : Converter<String, Uuid> {
    override fun String.convert(): Uuid {
        // ..
    }
}
----

- gon :
+

[source, kotlin]
----
@Transactional
@Schedule(3)
fun scheduleTask() {
    if(list.isEmpty()) { return }
    // doSomething
}
----
+

위 코드를 보시면 어떤 문제가 있을것으로 생각되나요? +
@Transactional을 너무 습관적으로 붙힌 안좋은 대표적인 예라고 생각합니다. +
위 코드의 경우 task가 어떠한 일을 하지않아도 3초마다 트랜잭션을 열고 닫습니다. +
그것이 스케줄링에서 원하는 행동이라면 상관없지만 보통은 스케줄링돌때 아무일도 안하는 경우에 트랜잭션을 열 이유는 없기때문에 +
@Transactional을 사용한다면 꼭 그뒤의 동작을 잘 예상하면서 사용해야 한다.

- gyeongtae: 어제 AI engineer랑 Front 앞으로의 미래에 대해서 얘기를 나눴다. 요즘 AI를 활용한 UI 개발이 아주 빨라지고 있는데 과연 앞으로도 React가 쓰일까? HTML + CSS + jquery 같은 단순한 형태로 가도 되지 않을까란 얘기가 주였다. 삼신기라고 하면서 설명을 했는데 비슷한 생각을 나 또한 하고 있다. 앞으로 FE의 미래가 궁금해지긴 한다. 관련 자료들을 찾아보면 좋을거같다.

[[section-202404-W2]]
=== 2024년 04월 2주
- hwan: MacOS 에서 Android Build 를 하면 환경변수로 설정한 JAVA_HOME 을 무시하고 /Applications/Android Studio.app/Contents/jre/Contents/Home 를 강제로 JAVA_HOME 으로 설정해 버린다. 이 때문에 Android Studio 의 JDK 보다 높은 버전의 라이브러리를 이용할 경우 JDK Version 이 맞지 않는 문제가 발생한다. Android Studio 를 삭제해서 당장 문제를 해결하긴 했지만 근본적인 해결책이 무엇일까...

- gon : 
클라이언트가 서버로부터 실시간으로 정보를 받기위한 방법

폴링(Polling) +
- **특징**: 클라이언트가 정기적으로 서버에 HTTP 요청을 보내어 최신 정보를 요청하는 방식입니다. +
- **장점**: 구현이 간단하고 모든 웹 환경에서 사용할 수 있습니다. +
- **단점**: HTTP 요청과 응답을 지속적으로 반복함으로써 발생하는 오버헤드가 크고, 실시간성이 떨어집니다.

롱 폴링(Long Polling) +
- **특징**: 클라이언트에서 서버로 요청을 보내고, 서버에서 새로운 데이터가 있을 때까지 요청을 보류하다가 데이터가 준비되면 응답하는 방식입니다. +
- **장점**: 실시간성이 향상되며, 폴링에 비해 HTTP 요청의 수가 감소합니다. +
- **단점**: 동시에 많은 클라이언트가 연결될 경우 서버 부하가 증가할 수 있습니다. 

WebSocket +
- **특징**: 클라이언트와 서버 간에 전이중 통신 채널을 제공하여 양방향 통신을 가능하게 하는 기술입니다. +
- **장점**: 지속적인 연결을 통해 실시간성이 매우 높고, 데이터 교환 시 오버헤드가 낮습니다. +
- **단점**: HTTP 프로토콜 위에서 작동하지만 별도의 프로토콜이 필요하며, 모든 웹 환경에서 지원되지 않을 수 있습니다.

SSE(Server-Sent Events) +
- **특징**: 서버에서 클라이언트로 단방향으로 데이터를 실시간으로 푸시하는 방식입니다. 기존 HTTP 연결을 재사용합니다. +
- **장점**: HTTP 프로토콜을 사용하므로 구현이 간단하며, 별도의 프로토콜이 필요하지 않습니다. WebSocket에 비해 더 가볍고 단순합니다. +
- **단점**: 단방향 통신만 가능하므로, 클라이언트에서 서버로의 실시간 통신이 필요한 경우에는 적합하지 않을 수 있습니다.

FCM(Firebase Cloud Messaging) +
- **특징**: 구글이 제공하는 클라우드 메시징 서비스로, 앱이나 웹에 무료로 메시지를 보낼 수 있습니다. +
- **장점**: 다양한 플랫폼에서 사용 가능하며, 대규모로 메시지를 보낼 수 있습니다. +
- **단점**: 실시간성에 제한이 있을 수 있고, 외부 서비스에 대한 의존도가 생깁니다.

- gyeongate: typescript를 도입하는 과정에서 mocking이 안되는 문제를 해결하기위해 찾아보니 mock에 여러 종류가 있어 찾아보았다. 
  * mock: 의존성이 주입 되는 시점에 모방한 객체, 모방된 객체는 동작에 대한 결과를 미리 정의할 수 있으며 몇번 호출 되었는지, 호출이 되었는지를 검증할 수 있다.
  * spy : Spy 객체는 실제 의존성의 행동을 유지하면서 호출에 대한 추가적인 정보를 기록함. Spy는 실제 객체의 래퍼(wrapper)로 동작하여 실제 로직을 실행하지만, 메서드 호출 횟수, 전달된 인자 등과 같은 추가적인 정보를 기록
  * stub : 미리 정의된 응답을 제공해주는 객체 일반적으로 테스트를 특정 방향으로 안내하기 위해 시뮬레이션되는 객체, mock과는 달리 유연하게 동작에 대한 응답을 미리 정의하는 것이 어렵다.


[[section-202404-W3]]
=== 2024년 04월 3주
- hwan: MongoDB 는 트랜잭션을 쓰려면 반드시 클러스터로 운영해야 한다. 이 때문에 마이그레이션을 해야 했다. 
+

. 데이터 덤프 및 서비스 stop
+

[source, shell]
----
db.shutdown();

mongodump --out /path/to/restore
----
+

. 클러스터로 쓸 호스트에 mongod 를 추가 설치하고 시작 옵션을 조절해 Replica set 설정
+

[source, shell]
----
mongod --replSet ${REPLICA_SET}
----
+

. Master cluster 에 replica set 을 설정
+

[source, shell]
----
rs.initiate();
rs.add({host: \"$NAME_REPL_1:$PORT_REPL_1\", priority: 0.5});
----
+

. master cluster 의 mongosh 에 접속후 dump 한 데이터를 import
+

[source, shell]
----
mongorestore /path/to/restore
----

+
. 데이터 정상 이동여부를 확인.
+

[source, shell]
----
db.collection.count()
----

- gon : `@ConditionalOnProperty` 는 조건부 빈 생성을 위한 주석Annotation이다. @ConditionalOnProperty는 주어진 속성(프로퍼티)이 특정한 값을 가질 때만 스프링 빈을 생성하거나 설정하도록 합니다.
yml이나 application.properties에 특정한 값이 있을때만 bean을 등록하게끔 할 수 있다.
문법은 다음과 같다
+

[source, kotlin]
----
@Configuration
@ConditionalOnProperty(name = ["myapp.feature.enabled"], havingValue = "true")
class MyFeatureConfiguration {

    @Bean
    fun myFeatureService(): MyFeatureService {
        return MyFeatureService()
    }

}
----


- wongue: Xcode 의 min deployment target 을 ios 업데이트 마다 재깍재깍 올려주는게 좋다. +
애플은 새로운 ios 버전 배포 이후, 가끔씩 이전 버전의 ios 지원을 걍 날려버리고, 따로 경고나 빌드시 오류를 주지 않는 경우가 종종 발생한다.

[[section-202404-W4]]
=== 2024년 04월 4주
- hwan: HTTP GET 에 Body 를 보내는 행위는 '일반적' 으로 잘못된 행위라고 인식해 왔다. 그러나 그걸 잘못되었다고 인식하는 것은 잘못되었다. HTTP 를 정의한 link:https://www.rfc-editor.org/rfc/rfc2616#section-4.3[RFC 2616] 에서는 
+

> entity-body 맥락을 정의하지 않은 요청이 message-body 를 포함한 경우 이를 되도록(SHOULD) 무시하도록 구현해야 한다
+

라는 구문이 있었다. 그러나 2014년에 HTTP 를 새로 정의한 RFC 7230 부터 RFC 7237 중 link:https://datatracker.ietf.org/doc/html/rfc7231#section-4.3[RFC 7231] 에 따르면 원래의 정의가 제거되었을 뿐 아니라 GET 요청에 대한 정의도 다음과 같이 변경되었다.
+

> GET 요청의 payload(맥락상 message-body) 는 정의된 맥락을 가지지 않는다. payload body 를 가진 GET 요청은, (서버측에서) 요청을 거절하기 위한 구현을 추가해야 할 수도 있다.
+

즉, Request body 를 포함한 GET 요청을 거부할지 말지는 서버의 몫이며 RFC 에서는 잘못되었다는 표현을 하지 않도록 변경되었다는 것이다. 10년 전에 변경된 사양을 이제서야 알게 되다니 부끄러운 한 주였다. 다만, 문서에서 이를 허용해 줬다 해서 GET 에 request body 를 담는 구현을 허용할지 말지를 가지고 싸우는 일은 피했으면 좋겠다. 예를 들어 GET 요청의 경우 복수 개의 parameter 를 표현하는 일은 대부분 번거롭다.
+

[source, shell]
----
GET https://my-site/user/profiles/ABCD,EFGH,IJKL,MNOP,QRST,UVWX

또는

GET https://my-site/user?profile=ABCD&profile=EFGH&profile=IJKL&profile=MNOP&profile=QRST&profile=UVWX
----
+

어느 쪽이던 표현이 깔끔하지 않다. 이런 경우 request body 를 포함한 GET method 를 허용하는 것도 고려한다던가 하는 유연함을 가지는 것도 좋을 것 같다.

- gyeongtae: 도메인이란 문제의 영역을 말하고 문제의 영역을 어떻게 동작하게 만들 것인지가 DDD의 본질이라고 한다. 그리고 문제의 특정 영역을 동작시키기 위한 모델이 존재할 텐데, 이것을 도메인 모델이라고 하고 도메인 모델은 곧 코드가 된다. 그리고 이 코드는 자체만으로 도메인을 설명하는 문서 역할을 하게 된다. 아예 문서가 필요없다고 할 순 없지만 도메인 지식으로부터 표현된 도메인 모델 즉, 코드로도 비즈니스가 이해될 수 있게 작성하면 따로 문서가 필요 없을것이라고 한다.

- gon: 최근에 재미있는 에러 상황을 공유 받았는데 +
os가 절전모드등 비용 감소 모드에 들어갓다가 서버가 요청을 받으니 첫번째 요청은 무조건 실패로 나는 문제였습니다. +
실패의 이유는 Jpa가 db의 트랜잭션을 가져올려다 커넥션 타임아웃으로 에러가 발생하였습니다. +
이유는 절전모드로 쓰레드기아상태가 된 상태에서 히카리cp의 housekeeper가 스레드를 할당받지못해 커넥션을 새로 맺지못했고 커넥션풀에는 만료된 커넥션만 쌓여서 그렇습니다 +
해당 에러에서 배워야할 교훈 : 우리의 서버가 항상 쓰레드를 잘 받고 돌아갈꺼라고만 생각하진 말자
